# Clean Code Chapter 2

| Name and explenation | Reflection and Rules from Clean Code         
| ------------- |:-------------:|
| averageWordLength(text) - Function in TextAverage that calculates the average word length for the provided text      | averageWordLength is a clear and descriptive name, which make it easy to understand what the function is doing, it is an intention-revealing name (p. 18). It is a searchable name, as in, if someone wouldn't remember the name but know what the function was doing they could search either "avg" or "average" and they would be able to locate the function  (p. 22). It is a pronounceable name, so when talking to other developers the name can be pronounced and understood (p. 21). |
| countLetters(text)   - Function name in the TextCounter class that counts the number of letters    | This name is confusing because it is not inention-revealing (p. 18), it could mean 'How many letters are present?', 'How many times is X letter present', or 'How many letters are in word X' Confusing wording - do we mean how many Letters are present or Each letter? In this instance, every letter is counted once, but that is not clear from the function name and therefor it is bad naming. A better name would have been countTotalLettersInText as then the name would reveal the intention of the function .|
|   TextManipulator - Classname for one of the main classes in the module.    | This could be concidered a break of the Donâ€™t Be Cute rule (p. 26) as Manipulator per Google is "a person who controls or influences others in a clever or unscrupulous way.", which doesn't translate well to whay the function actually does. The code and functions in TextManipulator has two themes - replace and reverse text. A better solution could be to split this up in two seperate classes called TextReplacer and TextReverser. This would provide more clarity and be more aligned with Use Intention-Revealing Names (p. 18). |
|   letterFrequencyList - Variable name in the mostUsedLetters(text, topFive = 5) that check most used letters function in the TextFrequency class     | In the function a variable is named "letterFrequencyList" which is breaking the Avoid Disinformation (p. 19) rule which says that "Programmers must avoid leaving false clues that obscure the meaning of code". The variable name is breaking this because "letterFrequencyList" is not an actual List, and a List means something special to programmers. A better name could have been "letterFrequencyMap" to avoid giving false conclusions with the word List.  |
|     validateLength() - Function name in the TextInputValidator class that validates the length of the input   |  validateLength is a very generic name that can mean a lot of things, for example, that the length is within a certain range or not too long or too short. The naming can therefore be improved because it is not explicit. Improvement of context, for example, having the function placed in a well named class like TextInputValidator, brings a meaningful context to the funciton so it becomes clear what the function does in that context (p. 27-28)  |

## Reflection
The chapter is about providing meaningful names to variables, functions, classes and other aspects of the code. It also advise on what good naming is and what it is not. The importance of having thoughtful and good naming of the code is because it can provide a sort of "documentation" to what the code is about by being intention-revealing, which then makes it easier for the person reading it to understand and work with the code. I especially liked the part of the book about "Avoid Mental Mapping", as a junior developer, my idea of a senior developer would be someone that writes complicated code, code that is impossible to understand. However, this section of the book made me understand that writing complicating code that is difficult to understand is not a sign of superiority, and that developers should actively work on being understood. That good code is code that one and others can understand. What I would have liked for the author to also touch on the subject of how or if cultural backgrounds and cultural context can affect our naming and understanding. This is in the context that a lot of developers works remote today, and often they may be working with colleagues in different countries. It would be interesting to learn more about how to approach naming in a global context where not everyone has the same reference point.

# Clean Code Chapter 3 Reflection

| Name and explenation | Reflection and Rules from Clean Code         
| ------------- |:-------------:|
| mostUsedLetters(text, topFive = 5) - Function to get the Top 5 most used letters | The function is relatively small, which is adhering to the principle that functions should be small and do one thing - and do that thing well (p. 34-35). The second argument (topFive = 5) provides some flexibility in the code but sets a default number to 5. However, per the book, developers should strive to reduce the number of arguments, and preferbly has no arguemnts, as argument in a dyadic function can be, for example, mixed up (p. 40, 42).  | 
| mostUsedWords(text) - Function to calculate the most used words and return the top 5 |  This function is similar to mostUsedLetters(text, topFive = 5) but it has been refactored to just take one argument but still return the top 5. Monadic functions are, per the book, preferbly to dyadic (p. 40) and per the book this would then be the prefered way to write the function, even though it becomes less flexible, but one could then argue onw could break up the functionality of showing the top 5 to a function of its own. The name also clearly states what the function does (p. 39). | 
| validateLength - Function in the TextInputValidator class to validate the length  |  Here the function doesn't take any argument as it is handled in the constructor. However, as dicussed above, the name is unspecific and the name could be interpreted in different ways. This function is breaking the principle of Do One Thing (p. 35) as it checks both if there is an input and that the input length is less then a 1000. This function should preferby be split up in one function that check if the input is empty, and one that checks if the input length is shorter then 1000.|
| removeAdditionalSpaces() - Function in TextInputValidator to remove additional spaces | Per the book, functions should strive to not have any Side Effects, which is explained as "Your function promises to do one thing, but it also does other hidden things. Sometimes it will make unexpected changes to the variables of its own class." (p. 44), and esentially, this funciton has side effects as it modifies the state of the object when it is changing `this.text`. Ideally, a new value should be returned, aka. a new string with the additional spaces removed, that doesn't alter the original `this.text`.  |
| replaceWord(text, wordToReplace, wordToReplaceWith) - Function in TextManipulator to replace one word with another.  | As mentioned earlier, having multiple arguments is generally discouraged in the book as it can make the function harder to understand and use. So while this is manageable, we should try, when possible, to reduce the number of arguments by refactore the code from a triad as it can reduce the number of possible errors (p. 40-42). The function also validates the inputs and throws errors when the types of the three arguments are not strings or empty strings. And while the error handeling can be extended to, for example, check if the word to replace is in the text, error handling is a good practice as it provides clear feedback on incorrect usage (p. 46).|

## Reflection

While I agree with the book that small functions that do one thing is preferable when one wants to quickly make the reader of the code engage in it and understand it. Small, focused, and purposeful functions that are understandable and manageable can be preferable in a lot of situations. However, is there a risk that small, single-purpose functions can be used to an absurdum, which in its extent can make the code fragmented, which makes it more difficult to understand the overall purpose and context of the application. The book also encourages the developer to, at least, make a conscious decision on how many arguments a function should take and try to reduce that number as it can enhance clarity and reduce errors. While a reduced number of arguments may give enhanced clarity, in some cases, like with the mostUsedLetters(text, topFive = 5) and mostUsedWords(text) above, it comes with the cost of reduced flexibility. We can then think about if there are scenarios where a larger number of arguments is preferred to enhance expressiveness in variation, rather than what could be a more fixed function with less arguments.